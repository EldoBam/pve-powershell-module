#
# Proxmox PowerShell VE
# Generated module to access all Proxmox VE Api Endpoints. This module has been generated from the proxmox api description v. 9.0.8
# Version: 9.0.8
# Contact: mail@timo-wolf.de
# Generated by OpenAPI Generator: https://openapi-generator.tech
#

<#
.SYNOPSIS

No summary available.

.DESCRIPTION

No description available.

.PARAMETER AdvertiseSubnets
Advertise IP prefixes (Type-5 routes) instead of MAC/IP pairs (Type-2 routes). EVPN zone only.
.PARAMETER Bridge
the bridge for which VLANs should be managed. VLAN & QinQ zone only.
.PARAMETER BridgeDisableMacLearning
Disable auto mac learning. VLAN zone only.
.PARAMETER Controller
ID of the controller for this zone. EVPN zone only.
.PARAMETER Dhcp
Name of DHCP server backend for this zone.
.PARAMETER DisableArpNdSuppression
Suppress IPv4 ARP && IPv6 Neighbour Discovery messages. EVPN zone only.
.PARAMETER Dns
ID of the DNS server for this zone.
.PARAMETER Dnszone
Domain name for this zone.
.PARAMETER Exitnodes
List of PVE Nodes that should act as exit node for this zone. EVPN zone only.
.PARAMETER ExitnodesLocalRouting
Create routes on the exit nodes, so they can connect to EVPN guests. EVPN zone only.
.PARAMETER ExitnodesPrimary
Force traffic through this exitnode first. EVPN zone only.
.PARAMETER Ipam
ID of the IPAM for this zone.
.PARAMETER Mac
MAC address of the anycast router for this zone.
.PARAMETER Mtu
MTU of the zone, will be used for the created VNet bridges.
.PARAMETER Nodes
Nodes where this zone should be created.
.PARAMETER Peers
Comma-separated list of peers, that are part of the VXLAN zone. Usually the IPs of the nodes. VXLAN zone only.
.PARAMETER Reversedns
ID of the reverse DNS server for this zone.
.PARAMETER RtImport
Route-Targets that should be imported into the VRF of this zone via BGP. EVPN zone only.
.PARAMETER Tag
Service-VLAN Tag (outer VLAN). QinQ zone only
.PARAMETER VlanProtocol
VLAN protocol for the creation of the QinQ zone. QinQ zone only.
.PARAMETER VrfVxlan
VNI for the zone VRF. EVPN zone only.
.PARAMETER VxlanPort
UDP port that should be used for the VXLAN tunnel (default 4789). VXLAN zone only.
.OUTPUTS

ClusterSdnZonesInnerPending<PSCustomObject>
#>

function Initialize-PVEClusterSdnZonesInnerPending {
    [CmdletBinding()]
    Param (
        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [System.Nullable[Boolean]]
        ${AdvertiseSubnets},
        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [String]
        ${Bridge},
        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [System.Nullable[Boolean]]
        ${BridgeDisableMacLearning},
        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [String]
        ${Controller},
        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [ValidateSet("dnsmasq")]
        [String]
        ${Dhcp},
        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [System.Nullable[Boolean]]
        ${DisableArpNdSuppression},
        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [String]
        ${Dns},
        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [String]
        ${Dnszone},
        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [String]
        ${Exitnodes},
        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [System.Nullable[Boolean]]
        ${ExitnodesLocalRouting},
        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [String]
        ${ExitnodesPrimary},
        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [String]
        ${Ipam},
        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [String]
        ${Mac},
        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [System.Nullable[Int32]]
        ${Mtu},
        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [String]
        ${Nodes},
        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [String]
        ${Peers},
        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [String]
        ${Reversedns},
        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [String]
        ${RtImport},
        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [System.Nullable[Int32]]
        ${Tag},
        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [ValidateSet("802.1q", "802.1ad")]
        [String]
        ${VlanProtocol} = "802.1q",
        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [System.Nullable[Int32]]
        ${VrfVxlan},
        [Parameter(ValueFromPipelineByPropertyName = $true)]
        [System.Nullable[Int32]]
        ${VxlanPort} = 4789
    )

    Process {
        'Creating PSCustomObject: ProxmoxPVE => PVEClusterSdnZonesInnerPending' | Write-Debug
        $PSBoundParameters | Out-DebugParameter | Write-Debug

        if ($Tag -and $Tag -lt 0) {
          throw "invalid value for 'Tag', must be greater than or equal to 0."
        }

        if ($VrfVxlan -and $VrfVxlan -gt 16777215) {
          throw "invalid value for 'VrfVxlan', must be smaller than or equal to 16777215."
        }

        if ($VrfVxlan -and $VrfVxlan -lt 1) {
          throw "invalid value for 'VrfVxlan', must be greater than or equal to 1."
        }

        if ($VxlanPort -and $VxlanPort -gt 65536) {
          throw "invalid value for 'VxlanPort', must be smaller than or equal to 65536."
        }

        if ($VxlanPort -and $VxlanPort -lt 1) {
          throw "invalid value for 'VxlanPort', must be greater than or equal to 1."
        }


		 $DisplayNameMapping =@{
			"AdvertiseSubnets"="advertise-subnets"; "Bridge"="bridge"; "BridgeDisableMacLearning"="bridge-disable-mac-learning"; "Controller"="controller"; "Dhcp"="dhcp"; "DisableArpNdSuppression"="disable-arp-nd-suppression"; "Dns"="dns"; "Dnszone"="dnszone"; "Exitnodes"="exitnodes"; "ExitnodesLocalRouting"="exitnodes-local-routing"; "ExitnodesPrimary"="exitnodes-primary"; "Ipam"="ipam"; "Mac"="mac"; "Mtu"="mtu"; "Nodes"="nodes"; "Peers"="peers"; "Reversedns"="reversedns"; "RtImport"="rt-import"; "Tag"="tag"; "VlanProtocol"="vlan-protocol"; "VrfVxlan"="vrf-vxlan"; "VxlanPort"="vxlan-port"
        }
		
		 $OBJ = @{}
		foreach($parameter in   $PSBoundParameters.Keys){
			#If Specifield map the Display name back
			$OBJ.($DisplayNameMapping.($parameter)) = $PSBoundParameters.$parameter
		}

		$PSO = [PSCustomObject]$OBJ


        return $PSO
    }
}

<#
.SYNOPSIS

Convert from JSON to ClusterSdnZonesInnerPending<PSCustomObject>

.DESCRIPTION

Convert from JSON to ClusterSdnZonesInnerPending<PSCustomObject>

.PARAMETER Json

Json object

.OUTPUTS

ClusterSdnZonesInnerPending<PSCustomObject>
#>
function ConvertFrom-PVEJsonToClusterSdnZonesInnerPending {
    Param(
        [AllowEmptyString()]
        [string]$Json
    )

    Process {
        'Converting JSON to PSCustomObject: ProxmoxPVE => PVEClusterSdnZonesInnerPending' | Write-Debug
        $PSBoundParameters | Out-DebugParameter | Write-Debug

        $JsonParameters = ConvertFrom-Json -InputObject $Json

        # check if Json contains properties not defined in PVEClusterSdnZonesInnerPending
        $AllProperties = ("advertise-subnets", "bridge", "bridge-disable-mac-learning", "controller", "dhcp", "disable-arp-nd-suppression", "dns", "dnszone", "exitnodes", "exitnodes-local-routing", "exitnodes-primary", "ipam", "mac", "mtu", "nodes", "peers", "reversedns", "rt-import", "tag", "vlan-protocol", "vrf-vxlan", "vxlan-port")
        foreach ($name in $JsonParameters.PsObject.Properties.Name) {
            if (!($AllProperties.Contains($name))) {
                throw "Error! JSON key '$name' not found in the properties: $($AllProperties)"
            }
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "advertise-subnets"))) { #optional property not found
            $AdvertiseSubnets = $null
        } else {
            $AdvertiseSubnets = $JsonParameters.PSobject.Properties["advertise-subnets"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "bridge"))) { #optional property not found
            $Bridge = $null
        } else {
            $Bridge = $JsonParameters.PSobject.Properties["bridge"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "bridge-disable-mac-learning"))) { #optional property not found
            $BridgeDisableMacLearning = $null
        } else {
            $BridgeDisableMacLearning = $JsonParameters.PSobject.Properties["bridge-disable-mac-learning"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "controller"))) { #optional property not found
            $Controller = $null
        } else {
            $Controller = $JsonParameters.PSobject.Properties["controller"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "dhcp"))) { #optional property not found
            $Dhcp = $null
        } else {
            $Dhcp = $JsonParameters.PSobject.Properties["dhcp"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "disable-arp-nd-suppression"))) { #optional property not found
            $DisableArpNdSuppression = $null
        } else {
            $DisableArpNdSuppression = $JsonParameters.PSobject.Properties["disable-arp-nd-suppression"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "dns"))) { #optional property not found
            $Dns = $null
        } else {
            $Dns = $JsonParameters.PSobject.Properties["dns"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "dnszone"))) { #optional property not found
            $Dnszone = $null
        } else {
            $Dnszone = $JsonParameters.PSobject.Properties["dnszone"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "exitnodes"))) { #optional property not found
            $Exitnodes = $null
        } else {
            $Exitnodes = $JsonParameters.PSobject.Properties["exitnodes"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "exitnodes-local-routing"))) { #optional property not found
            $ExitnodesLocalRouting = $null
        } else {
            $ExitnodesLocalRouting = $JsonParameters.PSobject.Properties["exitnodes-local-routing"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "exitnodes-primary"))) { #optional property not found
            $ExitnodesPrimary = $null
        } else {
            $ExitnodesPrimary = $JsonParameters.PSobject.Properties["exitnodes-primary"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "ipam"))) { #optional property not found
            $Ipam = $null
        } else {
            $Ipam = $JsonParameters.PSobject.Properties["ipam"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "mac"))) { #optional property not found
            $Mac = $null
        } else {
            $Mac = $JsonParameters.PSobject.Properties["mac"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "mtu"))) { #optional property not found
            $Mtu = $null
        } else {
            $Mtu = $JsonParameters.PSobject.Properties["mtu"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "nodes"))) { #optional property not found
            $Nodes = $null
        } else {
            $Nodes = $JsonParameters.PSobject.Properties["nodes"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "peers"))) { #optional property not found
            $Peers = $null
        } else {
            $Peers = $JsonParameters.PSobject.Properties["peers"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "reversedns"))) { #optional property not found
            $Reversedns = $null
        } else {
            $Reversedns = $JsonParameters.PSobject.Properties["reversedns"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "rt-import"))) { #optional property not found
            $RtImport = $null
        } else {
            $RtImport = $JsonParameters.PSobject.Properties["rt-import"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "tag"))) { #optional property not found
            $Tag = $null
        } else {
            $Tag = $JsonParameters.PSobject.Properties["tag"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "vlan-protocol"))) { #optional property not found
            $VlanProtocol = $null
        } else {
            $VlanProtocol = $JsonParameters.PSobject.Properties["vlan-protocol"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "vrf-vxlan"))) { #optional property not found
            $VrfVxlan = $null
        } else {
            $VrfVxlan = $JsonParameters.PSobject.Properties["vrf-vxlan"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "vxlan-port"))) { #optional property not found
            $VxlanPort = $null
        } else {
            $VxlanPort = $JsonParameters.PSobject.Properties["vxlan-port"].value
        }

        $PSO = [PSCustomObject]@{
            "advertise-subnets" = ${AdvertiseSubnets}
            "bridge" = ${Bridge}
            "bridge-disable-mac-learning" = ${BridgeDisableMacLearning}
            "controller" = ${Controller}
            "dhcp" = ${Dhcp}
            "disable-arp-nd-suppression" = ${DisableArpNdSuppression}
            "dns" = ${Dns}
            "dnszone" = ${Dnszone}
            "exitnodes" = ${Exitnodes}
            "exitnodes-local-routing" = ${ExitnodesLocalRouting}
            "exitnodes-primary" = ${ExitnodesPrimary}
            "ipam" = ${Ipam}
            "mac" = ${Mac}
            "mtu" = ${Mtu}
            "nodes" = ${Nodes}
            "peers" = ${Peers}
            "reversedns" = ${Reversedns}
            "rt-import" = ${RtImport}
            "tag" = ${Tag}
            "vlan-protocol" = ${VlanProtocol}
            "vrf-vxlan" = ${VrfVxlan}
            "vxlan-port" = ${VxlanPort}
        }

        return $PSO
    }

}

